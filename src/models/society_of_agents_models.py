"""
TODO: planned for the next phase; samples based on camel.ai's code
"""

from pydantic import BaseModel, Field
from typing import List, Optional


# ==== Define Pydantic Models ====


class AgentMessage(BaseModel):
    """Model for a single message."""

    role: str = Field(
        ..., description="The role of the agent (e.g., 'Assistant', 'Critic')."
    )
    content: str = Field(..., description="The content of the message.")


class HumanResponse(BaseModel):
    """Model for a human response."""

    response: str = Field(..., description="The response from the human.")


class AgentResponse(BaseModel):
    """Model for agent responses, including potential follow-ups."""

    role: str = Field(..., description="The role of the responding agent.")
    original_question: str = Field(
        ..., description="The original question generated by the Assistant."
    )
    refined_question: Optional[str] = Field(
        None, description="The refined follow-up question by the Critic."
    )
    human_response: str = Field(
        ..., description="The human's response used to refine the question."
    )


# ==== Define Agent Classes ====


class BaseAgent:
    def __init__(self, role: str):
        self.role = role

    def process_message(self, *args, **kwargs) -> str:
        """Abstract method to be implemented by subclasses."""
        raise NotImplementedError


class AssistantAgent(BaseAgent):
    """Agent to generate the initial question."""

    def process_message(self, topic: str) -> AgentMessage:
        question = f"What are your thoughts on {topic}?"
        return AgentMessage(role=self.role, content=question)


class CriticAgent(BaseAgent):
    """Agent to refine the question based on the human response."""

    def process_message(self, question: str, human_response: str) -> AgentMessage:
        if "storage" in human_response.lower():
            refined_question = f"Can you elaborate on specific storage solutions for {question.split()[-1]}?"
        else:
            refined_question = (
                f"Could you explain your view further about {question.split()[-1]}?"
            )
        return AgentMessage(role=self.role, content=refined_question)


# ==== Define Society Class ====


class QuestionGenerationSociety:
    def __init__(self, assistant: AssistantAgent, critic: CriticAgent):
        self.assistant = assistant
        self.critic = critic

    def interact(
        self, topic: str, human_responses: List[HumanResponse]
    ) -> List[AgentResponse]:
        """Simulate interactions and produce follow-up questions."""
        responses = []
        for human_response in human_responses:
            # Step 1: Assistant generates an initial question
            assistant_message = self.assistant.process_message(topic)

            # Step 2: Critic refines the question based on the human response
            critic_message = self.critic.process_message(
                assistant_message.content, human_response.response
            )

            # Step 3: Create a structured response using Pydantic
            agent_response = AgentResponse(
                role="Critic",
                original_question=assistant_message.content,
                refined_question=critic_message.content,
                human_response=human_response.response,
            )
            responses.append(agent_response)
        return responses


# ==== Simulation ====

# Instantiate Agents
assistant = AssistantAgent(role="Assistant")
critic = CriticAgent(role="Critic")

# Instantiate Society
society = QuestionGenerationSociety(assistant, critic)

# Define Inputs
topic = "renewable energy"
human_responses = [
    HumanResponse(response="I think storage solutions are essential for solar energy."),
    HumanResponse(response="Wind energy is reliable, but distribution is a challenge."),
]

# Run the Society
results = society.interact(topic, human_responses)

# Display Results
for idx, result in enumerate(results, 1):
    print(f"Interaction {idx}:")
    print(f"  Original Question: {result.original_question}")
    print(f"  Human Response: {result.human_response}")
    print(f"  Refined Question: {result.refined_question}\n")
